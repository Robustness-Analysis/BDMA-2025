---
title: "Clustering of Techniques"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Heirarchy

## Preliminary steps

Load libraries

```{r include=FALSE}
# Packages that need to be loaded
library(dplyr)
library(tidyr)
library(ggplot2)
library(GGally) # extensi√≥n de ggplot2
library(factoextra) # visualizacion de los clusters
library(NbClust) # determinar el mejor numero de grupos
library(cluster) # medidas de evaluacion como silhouette
```

Load files

```{r include=FALSE}
# Load files
datasets <- readRDS("../files/datasets.rds")
method_names = readRDS("../files/method_names.rds")
noise_level <- readRDS("../files/noise.rds")
noise_names <- readRDS("../files/noise_names.rds")
instances_names = readRDS("../files/instances_names.rds")
quartiles_names = c("25", "50", "75", "100")

# Load results
meanKLC <- readRDS("../results/meanKLC_d.rds") # This is df2 from Aggregate_Curves
meanKLC_q <- readRDS("../results/meanKLC_q.rds") # This is df2_q from Aggregate_Curves
```

## Obtain the heirarchy

### Preprocess the data

Transform the data to generate a dataframe of 40 variables for each technique

```{r echo=TRUE}
# Transform the data
wide_data <- meanKLC_q %>%
  unite("noise_percentage", noise, percentage, sep = "_") %>%
  spread(key = noise_percentage, value = kappa_loss)

# View the transformed data
print(wide_data)
```

### Obtain distance matrix

Compute the distance matrix

```{r include=FALSE}
distance_matrix <- dist(wide_data, method = "euclidean")
```

Calculate elbow and silhouette to find the optimal number of clusters

```{r eval=FALSE, include=FALSE}
# method parameters: "silhouette", "wss", "gap_stat"
print(fviz_nbclust(data_renamed, kmeans, method = "wss") + geom_vline(xintercept = 3, linetype = 2) + labs(subtitle = "Elbow method") + theme_minimal())
```

Perform Heriarchical Clustering

```{r include=FALSE}
# Create a vector of colors based on the number of clusters
colors <- c("#4FB28F","#8F4FB2", "#3681F7", "#F65215")
# Extra color: "#F7AC36"
```

```{r echo=TRUE}
k_list = c(4)
for(i in k_list) {
  # Perform hierarchical clustering
  hclusters <- hclust(distance_matrix, method = "ward")

  # Plot dendrogram with labels
  p <- plot(hclusters, hang = -1, labels = wide_data$technique, main = paste("Hierarchical Grouping (k =", i, ")"), xlab = "Observations", sub = NULL)
  rect.hclust(hclusters, k = i, border = colors[1:i])

  # Plot dendrogram without labels
  plot(hclusters, hang = -1, main = paste("Hierarchical Grouping (k =", i, ")"), 
       xlab = "Observations", sub = NULL)
  rect.hclust(hclusters, k = i, border = colors[1:i])

  # Divide dendrogram into groups
  groups <- cutree(hclusters, k = i)

  # Compute silhouette coefficient for hierarchical clustering
  sil <- silhouette(groups, dist = distance_matrix)

  # Create silhouette plot
  plot(sil, col = colors[1:i], main = paste("Silhouette Plot (k =", i, ")"))

  ggsave("../results/plots/dendogram.png", p, width = 40, height = 40, dpi = 600)
}
```

```{r include=FALSE}
clusters <- cutree(hclusters, k = 4)

print(clusters)
```

## Plots

```{r eval=FALSE, include=FALSE}
# Get the highest kappa loss for each technique in each quartile
meanKLC_results <- meanKLC_q[meanKLC_q$noise == 100, c("technique", "percentage", "kappa_loss")]
print(meanKLC_results)
```

```{r echo=TRUE}
# First get unique techniques in the same order as used for clustering
techniques <- wide_data$technique  # assuming technique is a column in wide_data

# Create the mapping dataframe
technique_clusters <- data.frame(
  technique = techniques,
  cluster = clusters
)

# Now join with original data and filter
meanKLC_q_with_clusters <- meanKLC_q %>%
  left_join(technique_clusters, by = "technique")

# Get the highest kappa loss for each cluster in each quartile
cluster_results <- meanKLC_q_with_clusters[c("cluster", "noise", "percentage", "kappa_loss")]
print(cluster_results)
```

```{r echo=TRUE}
# Calculate mean kappa loss for each cluster, noise level, and percentage
cluster_means <- cluster_results %>%
  group_by(cluster, noise, percentage) %>%
  summarize(kappa_loss = round(mean(kappa_loss, na.rm = TRUE), 2)) %>%
  ungroup()

print(cluster_means)
```

```{r echo=TRUE}
for(instance in quartiles_names) {
  # Filter data for the current instance percentage
  filtered_data <- subset(meanKLC_q, percentage == instance)
  
  # Create plot
  p1 <- ggplot(filtered_data, aes(x = noise, y = kappa_loss, color = factor(technique))) +
  geom_point() +
  geom_line(aes(noise)) +
  labs(x = "Noise", y = "Kappa Loss", color = "Technique") +
  ggtitle(paste0("Kappa Loss Curves by technique, noise and ", instance, " % of instances altered")) +
  theme_bw() +
  scale_y_continuous(limits = c(0.0, 0.5), breaks = seq(0, 1, by = 0.1))
  
  # Print plot
  print(p1)
}
```

```{r echo=TRUE}
for(instance in quartiles_names) {
  # Filter data for the current instance percentage
  filtered_data <- subset(cluster_means, percentage == instance)
  
  # Create plot
  p2 <- ggplot(filtered_data, aes(x = noise, y = kappa_loss, color = factor(cluster))) +
  geom_point() +
  geom_line(aes(noise)) +
  labs(x = "Noise", y = "Kappa Loss", color = "Cluster") +
  ggtitle(paste0("Kappa Loss Curves by cluster, noise and ", instance, " % of instances altered")) +
  theme_bw() +
  scale_y_continuous(limits = c(0.0, 0.5), breaks = seq(0, 1, by = 0.1))
  
  # Print plot
  print(p2)
}
```

```{r include=FALSE}
# Create a named vector to map clusters to specific colors
cluster_colors <- c(
  "1" = "#4FB28F",
  "2" = "#8F4FB2",
  "3" = "#3681F7",
  "4" = "#F65215"
)
```

```{r echo=TRUE}
# Create an empty list to store plots
plot_list <- list()

# Create all plots and store them in the list
for(i in seq_along(quartiles_names)) {
  instance <- quartiles_names[i]
  
  # Filter data for both techniques and clusters
  filtered_tech_data <- subset(meanKLC_q, percentage == instance)
  
  # Join cluster information to the technique data
  filtered_tech_data <- filtered_tech_data %>%
    left_join(technique_clusters, by = "technique")
    
  filtered_cluster_data <- subset(cluster_means, percentage == instance)
  
  # Create combined plot
  combined_plot <- ggplot() +
    # Add technique lines with colors based on their cluster
    geom_line(data = filtered_tech_data, 
              aes(x = noise, y = kappa_loss, group = technique, color = factor(cluster)),
              linetype = "solid", alpha = 0.5) +
    geom_point(data = filtered_tech_data,
               aes(x = noise, y = kappa_loss, group = technique, color = factor(cluster)),
               alpha = 0.5) +
    
    # Add thicker cluster lines to show the averages
    geom_line(data = filtered_cluster_data,
              aes(x = noise, y = kappa_loss, group = cluster, color = factor(cluster)),
              linewidth = 1.5) +
    geom_point(data = filtered_cluster_data,
               aes(x = noise, y = kappa_loss, group = cluster, color = factor(cluster)),
               size = 3) +
    
    # Set the specific color mapping
    scale_color_manual(name = "Cluster", values = cluster_colors) +
    
    # Customize the plot
    scale_y_continuous(limits = c(0.0, 0.5), breaks = seq(0, 1, by = 0.1)) +
    labs(x = "Noise",
         y = "Kappa Loss",
         title = paste0(instance, "% of instances altered")) +
    theme_bw() +
    theme(legend.position = "right")
  
  # Store plot in list
  plot_list[[i]] <- combined_plot
}

# Arrange all plots in a grid using patchwork or gridExtra
if (requireNamespace("patchwork", quietly = TRUE)) {
  # Using patchwork (preferred if available)
  library(patchwork)
  combined_grid <- wrap_plots(plot_list, ncol = 2) + 
    plot_annotation(title = "Kappa Loss Curves by Technique and Cluster")
  print(combined_grid)
} else if (requireNamespace("gridExtra", quietly = TRUE)) {
  # Using gridExtra as an alternative
  library(gridExtra)
  grid_title <- textGrob("Kappa Loss Curves by Technique and Cluster", gp = gpar(fontsize = 14))
  grid_arranged <- grid.arrange(grobs = plot_list, ncol = 2, top = grid_title)
  print(grid_arranged)
} else {
  # If neither package is available, print a message and show plots individually
  message("Please install either 'patchwork' or 'gridExtra' package for grid layout.")
  for (p in plot_list) {
    print(p)
  }
}

# Save the grid plot
ggsave("../results/plots/cluster_curves_grid.png", combined_grid, width = 40, height = 40, dpi = 600)
```
